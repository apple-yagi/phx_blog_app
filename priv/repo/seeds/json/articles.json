[
  {
    "title": "新卒研修で役に立った学生時代に勉強した技術",
    "content": "# はじめに\n今年の4月から新卒エンジニアになり、約2ヶ月の技術研修が終わったので、その時に役に立った技術を述べようと思います。\n\n# Git / Github\n<img src=\"https://cdn.svgporn.com/logos/github-octocat.svg\" alt=\"git\"/>\nまず一つ目はWeb開発では定番ツールのGit/Githubです。\n基本的に研修で作成した成果物は、Githubで上げて先輩にコードレビューしてもらう形で、Gitの使い方の研修はなかったので、学生時代に慣れておいてよかったです。\n\n習熟度は、プルリクエストベースでの開発ができる程度であれば大丈夫な感じでした。\n\n# Docker\n <img src=\"https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.svgporn.com%2Flogos%2Fdocker.svg?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=ffe3655310819d25c8e8258087ba4f63\" alt=\"docker\">\n\n次もWeb開発ではお馴染みとなっているDockerです。\nこれも研修はなく、バックエンド研修で普通に使うことになっていたので、学生時代に慣れておいて良かったです。\n\n習熟度は、Dockerの基本的なコマンドとdocker-composeでのコンテナ連携ができるくらいのレベルが必要でした。\n\n# クリーンアーキテクチャ\n![https___qiita-image-store.s3.amazonaws.com_0_293368_7ce1fb10-504e-16e0-8930-278b8a7f942d.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/c8c575c8-e127-cef2-3677-714e0006f0c3.jpeg)\n\n3つ目は、クリーンアーキテクチャの知識です。\nこの知識は、生のPHPでインスタ風のアプリケーションを作るという研修で役に立ちました。\nこの研修では、ORMなどのツールも極力利用しないことになっていたので、普通のMVCパターンではなくRepositoryパターンや責務分離についての知見がないと、良い感じにコードを書けないので、クリーンアーキテクチャの知識がとても役に立ちました。\n\n# SQL\n最後は、SQLの知識です。\nこれは生のPHPでアプリケーションを作る時と、自社のWebサービスのDBから知りたいデータを抽出する際に役に立ちました。\n\n習熟度は、基本的な構文の`SELECT`や`WHERE`、`JOIN`が理解できていれば、とりあえず大丈夫でした。\n\n# さいごに\n今回紹介した役に立った知識は、自分の働いている会社での話のため、ぜひ、今年入社した新卒エンジニアの方は、この記事のコメント欄に「自分の会社ではこんな知識が役に立った」などを教えてくれると嬉しいです！\n"
  },
  {
    "title": "Firestoreの公式ドキュメントに載っているコードをasync/awaitで書き直してみる",
    "content": "# はじめに\nFirebaseのデータストアの1つであるFirestoreの<a href=\"https://firebase.google.com/docs/firestore/query-data/get-data?hl=ja\">公式ドキュメント</a>のサンプルコードが全て**Promiseチェーン**になっているので、一部のコードを**async/await**で書き直してみます。\n\n# Promiseチェーンとは\n``` hoge.js\nvar docRef = db.collection(\"cities\").doc(\"SF\");\n\ndocRef.get().then((doc) => {\n    if (doc.exists) {\n        console.log(\"Document data:\", doc.data());\n    } else {\n        // doc.data() will be undefined in this case\n        console.log(\"No such document!\");\n    }\n}).catch((error) => {\n    console.log(\"Error getting document:\", error);\n});\n```\n上記のような **then** で非同期処理の結果を受け取る方法を**Promiseチェーン**と呼びます（正式名称かは不明）。\n\nこの記述を行うと、連続して非同期処理を行った時にコードの可読性が低下する要因となります。\n例えば、非同期処理が3連続すると以下のようなコードになります。\n\n```fuga.js\nvar docRef = db.collection(\"cities\").doc(\"SF\");\nvar docRef2 = db.collection(\"cities\").doc(\"LA\");\nvar docRef3 = db.collection(\"cities\").doc(\"DC\");\n\ndocRef.get().then((doc) => {\n  if (doc.exists) {\n    console.log(\"Document data:\", doc.data());\n  } else {\n    // doc.data() will be undefined in this case\n    console.log(\"No such document!\");\n\n    // データがなかった場合、docRef2のデータを取得する\n    docRef2.get().then((doc) => {\n      if (doc.exists) {\n        console.log(\"Document data:\", doc.data());\n      } else {\n        // doc.data() will be undefined in this case\n        console.log(\"No such document!\");\n\n        // データがなかった場合、docRef3のデータを取得する\n        docRef3.get().then((doc) => {\n          if (doc.exists) {\n            console.log(\"Document data:\", doc.data());\n          } else {\n            // doc.data() will be undefined in this case\n            console.log(\"No such document!\");\n          }\n        }).catch((error) => {\n          console.log(\"Error getting document:\", error);\n        })\n      }\n    }).catch((error) => {\n      console.log(\"Error getting document:\", error);\n    });\n  }\n}).catch((error) => {\n    console.log(\"Error getting document:\", error);\n});\n```\n\nこのように連続した**Promiseチェーン**はコードのネストが深くなりやすく、可読性が低くなります。\n\n# ドキュメントを取得する\n公式ドキュメントのコード\n\n```test.firebase.js\nvar docRef = db.collection(\"cities\").doc(\"SF\");\n\ndocRef.get().then((doc) => {\n  if (doc.exists) {\n    console.log(\"Document data:\", doc.data());\n  } else {\n    // doc.data() will be undefined in this case\n    console.log(\"No such document!\");\n  }\n}).catch((error) => {\n  console.log(\"Error getting document:\", error);\n});\n```\n\nasync/awaitを使用したコード\n\n```refactoring.firebase.js\nvar docRef = db.collection(\"cities\").doc(\"SF\");\n\nconst getDoc = async() => {\n  try {\n    const doc = await docRef.get();\n    if (doc.exists) {\n      console.log(\"Document data:\", doc.data());\n    } else {\n      // doc.data() will be undefined in this case\n      console.log(\"No such document!\");\n    }\n  } catch(error) {\n    console.log(\"Error getting document:\", error);\n  }\n}\n\n// この処理は非同期で実行される\ngetDoc();\n```\n\n3連続した非同期処理をasync/awaitに書き換える\n\n```refactoring.firebase.js\nvar docRef = db.collection(\"cities\").doc(\"SF\");\nvar docRef2 = db.collection(\"cities\").doc(\"LA\");\nvar docRef3 = db.collection(\"cities\").doc(\"DC\");\n\nconst getDoc = async() => {\n  try {\n    const doc = await docRef.get();\n    if (doc.exists) {\n      console.log(\"Document data:\", doc.data());\n      return;\n    }\n    // doc.data() will be undefined in this case\n    console.log(\"No such document!\");\n\n    // データがなかった場合、docRef2のデータを取得する\n    const doc2 = await docRef2.get();\n    if (doc.exists) {\n      console.log(\"Document data:\", doc2.data());\n      return;\n    }\n    // doc.data() will be undefined in this case\n    console.log(\"No such document!\");\n\n    // データがなかった場合、docRef3のデータを取得する\n    const doc3 = await docRef3.get();\n    if (doc.exists) {\n      console.log(\"Document data:\", doc3.data());\n      return;\n    }\n    // doc.data() will be undefined in this case\n    console.log(\"No such document!\");\n  } catch(error) {\n    console.log(\"Error getting document:\", error);\n  }\n}\n\n// この処理は非同期で実行される\ngetDoc();\n```\nPromiseチェーンが1つの場合は、ネストがあまり深くならないので**async/await**の恩恵をあまり感じませんが、複数の処理を実行する時は、ネストが深くなるのを抑えてくれます。\n\n# コレクションから複数のドキュメントを取得する\n公式ドキュメントのコード\n\n```test.firebase.js\ndb.collection(\"cities\").where(\"capital\", \"==\", true)\n  .get()\n  .then((querySnapshot) => {\n    querySnapshot.forEach((doc) => {\n      // doc.data() is never undefined for query doc snapshots\n      console.log(doc.id, \" => \", doc.data());\n    });\n  })\n  .catch((error) => {\n    console.log(\"Error getting documents: \", error);\n  });\n```\n\nasync/awaitを使用したコード\n\n```refactoring.firebase.js\nconst getDocs = async() => {\n  try {\n    const querySnapshot = await db.collection(\"cities\").where(\"capital\", \"==\", true);\n    querySnapshot.forEach((doc) => {\n      // doc.data() is never undefined for query doc snapshots\n      console.log(doc.id, \" => \", doc.data());\n    })\n  } catch(error) {\n    console.log(\"Error getting documents: \", error);\n  }\n}\n\n// この処理は非同期で実行される\ngetDocs();\n```\n\n# まとめ\nFirebaseのコードは全てPromiseチェーンで記述されているため、何も考えずにコードを書いていくと、ネストが深くなりがちです。\n**async/await**を使用して、ネストが少ないコードを心がけましょう！\n"
  },
  {
    "title": "TSUTAYAでアルバイトしていた学生エンジニアが退職するので置き土産に業務効率アプリを開発した話",
    "content": "# 概要\n私は、大学1~4年生までTSUTAYAで働いていた学生エンジニアです。\nこの度、大学を卒業し就職するためアルバイトを辞めるので、4年間も働いたTSUTAYAに何か最後に残せるものはないかと思い、業務で使えるアプリを作りました。\n\n# 開発したアプリの概要\n開発したアプリは、**食品の賞味期限を管理できるWebアプリケーション**です。\n使用した技術は、Next.jsとFirebaseでサクッと作りました。\n\n# 開発した背景\n私の勤めていたTSUTAYAでは食品を取り扱っているのですが、賞味期限の管理方法に少し問題を抱えていました。\nそれは、賞味期限を名簿に書いて管理していたことです。\nこれにより、以下のデメリットがありました。\n\n① **賞味期限の順にソートできない**\n② **紙による管理なので、かさばる**\n③ **賞味期限が過ぎていないか、いちいち名簿を見るのが面倒**\n\nまた、この名簿を管理する人は決まっておらず、気づいた人がやる形式だったので、ほとんど使用されていませんでした。\n\n# 開発したアプリの仕組み\n今回、開発したWebアプリは以下の構成で出来ています。\n![TSUTAYAでアルバイトしていた学生エンジニア.001.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/cf10d1b6-872b-bbb9-4e99-1029f9acdf0f.jpeg)\n\n商品が入荷すると、Next.jsで作成されたWebページ上で商品情報を入力し、登録します。\n情報は、Firestoreに保存されます。\n賞味期限の確認はGoogle Pub/Subを利用し、午後0時にFunctionsにFirestoreに登録されている商品の賞味期限の確認をするように合図を出します。\n\n# 工夫した点\nこのアプリを工夫した点、**1つ目はLINE Botで賞味期限の通知をする点です。**\nこれにより、商品のことを忘れていても勝手に通知が来るので、めっちゃ良いです。\n\n**2つ目は、意外な点でデザインです。**\n普通、業務で使うWebページやアプリは簡素なものが多く、面白くありません。\nただ、今回私が開発したアプリは、業務に必須なものではなく、効率化を図るためのものです。よって、利用しなくても業務に支障をきたすことがないため、スタッフが利用したいと思うものにする必要がありました。\nそのために、面白いアイデアを取り入れたデザインにしました。\n\n商品情報入力フォーム↓\n![スクリーンショット 2021-02-16 17.20.18.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/ccc2193d-5b4d-17b7-637d-ef42d24c123e.png)\n\n商品一覧テーブル↓\n![スクリーンショット 2021-02-16 17.20.37.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/f2446547-92f0-2173-46a6-c7139c1af332.png)\n\n上記が実際に作成したWebページになります。\nデザインはニューモフィズムというものを参考にしました。\nまた、アイコンを作成することにより、愛着のあるものにしました。\n\n**3つ目の工夫点は、Webページの表示速度です。**\nこれは、当たり前のことなんですが、表示に時間がかかるWebページは見たくないですよね？\nどれだけ便利なもので愛着のあるものでもインターネットの世界で、表示が遅いものは良くないと私は考えています。\n\n![https___qiita-image-store.s3.ap-northeast-1.amazonaws.com_0_533652_a5e197e7-2aac-92c4-6ec8-cfd428c3cd8b.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/9f559ade-33e1-2ef7-1bed-d4fc6b166f1d.png)\n\n\n上記の画像は、Lighthouseというツールでレンダリング速度などを測定した結果です。\nこの画像から、参考の数値にはなりますが、Performanceの点で100点を出すことができています。\nこれにより、Webページの表示速度もある程度速くすることができていることがわかると思います。\n\n# まとめ\nこのアプリを開発したことによって、名簿で管理する3つのデメリットを全て解消することができました。\nまた、このアプリは現在6つの店舗で利用されおり、業務改善に役立っていると思います。\n\n私は、すでにTSUTAYAを退職しているため、職場の人と直接的に関わることはなくなりましたが、このアプリを通して繋がれたら嬉しいです!!\n"
  },
  {
    "title": "学生エンジニアの自分が2020年に勉強したWeb技術",
    "content": "# 軽く自己紹介\n私は、現在大学4年生で2019年の11月からWeb(HTML, CSSから)について勉強をはじめました。\nそんな自分がこの一年(2019年11月~2020年12月)で、どのような技術を学んだのか、自分の備忘録も兼ねて紹介していきたいと思います。\nそれでは、早速紹介していきたいと思います。\n\n# HTML, CSS, JavaScript（学習期間2019年11月）\nこの3つは、わざわざいう必要も無いと思いましたが、一応書いておきます。\n普段、Webアプリを作っていれば、この3つは必然的に学習すると思いますが、これらだけを学習したのは、１週間くらいしかやって無いです。\nあとは、実際にWebアプリを作っていく中で学習していきました。\n\n# Ruby, Ruby on Rails（学習期間 2019年11~12月）\n<img src=\"https://cdn.svgporn.com/logos/rails.svg\" />\nRuby on Railsは、オープンソースのWebアプリケーションフレームワークである。RoRまたは単にRailsと呼ばれる。その名にも示されているようにRubyで書かれている。またModel View Controllerアーキテクチャに基づいて構築されている。\n<a href=\"https://rubyonrails.org/\" target=\"_blank\">公式ページ</a>\n\n自分が１番最初に学習したフレームワークは、Web系では定番のRuby on Railsです。\nこれを使って、初めての<a href=\"https://yagi-booklist.herokuapp.com/users/login\" target=\"_blank\">ポートフォリオ</a>を作成しました。\n\nこのフレームワークを学んで、MVCの概念やRESTfulなどWeb技術の基礎的な考え方を身につけることができたので、初学者の方には、おすすめしたいです。\nただ、最初の頃はフレームワークの処理の手順が正しく追えず、大変でした...\n\nRuby on Railsは自分の初めて学習したフレームワークなので愛着があり、他の大学生の人たちで使える人が多いので、チーム開発やハッカソンをするときに、よく使います。\n\n# Heroku（学習期間 2019年12月）\n<img src=\"https://cdn.svgporn.com/logos/heroku.svg\" />\nHerokuは2007年創業のアメリカ合衆国の企業。また、同社が開発と運営を行っているPaaSの名称でもある。2010年にはセールスフォース・ドットコムに買収された。\n<a href=\"https://jp.heroku.com/\" target=\"_blank\">公式ページ</a>\n\n自分の初めてのポートフォリオをネット上に公開するために使用しました。\n簡単にWebアプリケーションを公開することができるので、初めてのデプロイには、とてもおすすめです。\nただ、難点としてアクセス数が一定時間無いと、サーバがシャットダウンするようで、上記で紹介したポートフォリオも最初のアクセスに時間がかかることがわかると思います。\n\nHerokuは最初のポートフォリオをデプロイして以来、使用してなく、今後も使用しないと思います...\n\n# Django（学習期間 2019年12月~2020年1月）\n<img src=\"https://cdn.svgporn.com/logos/django.svg\" />\nDjangoは、Pythonで実装されたWebアプリケーションフレームワーク。MVCデザインパターンに緩やかに従う。もともとはアメリカ合衆国カンザス州ローレンスにあるWorld Companyのために、ニュース系のサイトを管理する目的で開発され、2005年7月にBSD Licenseで公式にリリースされた。\n<a href=\"https://docs.djangoproject.com/ja/3.1/\" target=\"_blank\">公式ページ</a>\n\n次に学習したフレームワークは、Djangoです。\nこれは、自分の所属している研究室で使用するツールを作成するために、学習しました。\nこちらの<a href=\"https://qiita.com/apple-yagi/items/5555d05d81dded3a69e1\" target=\"_blank\">Qiita記事</a>に記載してるので、もし良ければ見てください。\n\nこのフレームワークは、MVTパターンという少し変わった概念のフレームワークですが、Railsを学習している方であれば、処理の手順は追いやすいかと思います。\n実際に、私も２週間で研究室のツールを作れました。\n\nDjangoはPythonのフレームワークということもあって、少ないコード数でアプリケーションを作ることができます。Pythonを使った経験がある方には、とてもおすすめできるフレームワークです。\n\n# Aamazon Web Service（EC2）（学習期間 2020年1月）\n<img src=\"https://cdn.svgporn.com/logos/aws-ec2.svg\" />\nAmazon Elastic Compute Cloud (Amazon EC2) は、安全でサイズ変更可能なコンピューティング性能をクラウド内で提供するウェブサービスです。\n<a href=\"https://aws.amazon.com/jp/ec2/?ec2-whats-new.sort-by=item.additionalFields.postDateTime&ec2-whats-new.sort-order=desc\" target=\"_blank\">公式ページ</a>\n\n上記のDjangoのWebアプリをデプロイするために、使用しました。\nHerokuとの違いは、SSH接続してデプロイをしないといけないことや、ミドルウェアの設定などの諸々の設定を手動で行わないといけない点です。\nまた、ネットワークについての知識も必要となるため、デプロイの難易度がHerokuとは段違いに難しいです。\nしかし、メリットとしてアクセスがないときも起動しているため、初回のアクセスに時間がかかることはないのが強いと思います。\n\nAWSのEC2は、インフラ系の知識（SSH接続、ネットワークなど）を学ぶことができるので、Webアプリケーションをある程度作れるようになった方のステップアップとして、良いと思います。\n\n# Vue.js（学習期間 2020年2~3月）\n<img src=\"https://cdn.svgporn.com/logos/vue.svg\" />\nVue.jsまたはVueは、Webアプリケーションにおけるユーザーインターフェイスを構築するための、オープンソースのJavaScriptフレームワークである。他のJavaScriptライブラリを使用するプロジェクトへの導入において、容易になるように設計されている。\n<a href=\"https://jp.vuejs.org/index.html\" target=\"_blank\">公式ページ</a>\n\nRails, Djangoをやってきて、バックエンドをある程度把握することができたと思ったので、ここでVue.jsを学習しました。\nまた、アウトプットとして、<a href=\"https://gurustagram-app.firebaseapp.com/#/\" target=\"_blank\">Gurustagram</a>と言うWebアプリを作成しました。\n\nVue.jsを学習した時は、正直JavaScriptの知識は全くなかったですが、問題なく学習することができました。HTML, CSSをある程度理解していれば、なんとなくできるようになると思います。ただ、API通信やVuexあたりはJavaScriptの知識が必須になるので、Vue.jsと同時並行してJavaScriptも学習しました。\n\n# Firebase（学習期間 2020年2~3月）\n<img src=\"https://cdn.svgporn.com/logos/firebase.svg\" />\nFirebaseは、2011年にFirebase, Inc.が開発したモバイル・Webアプリケーション開発プラットフォームで、その後2014年にGoogleに買収された。 2020年3月現在、Firebaseプラットフォームには19の製品があり、9GAGを含む150万以上のアプリが利用されている。\n<a href=\"https://firebase.google.com/?hl=ja\" target=\"_blank\">公式ページ</a>\n\nVue.jsでWebアプリを作るときに、どうせならいつもと違う構成にしたいと思い、Firebaseを学習しました。\n一時期、サーバーサイドエンジニア不要論が出た通り、これが使えるようになればフロントエンドフレームワークだけである程度のWebアプリは作れてしまいます。\nただ、アプリケーションの規模が大きくなるに連れて、データベース設計などで問題が生じてくると思うので、あくまで個人開発や小規模アプリに限定されると思います。\n\nFirebaseは、ハッカソンなどの短期間でアプリを作るときに、とても使えるので持っておくと何かと便利な技術の1つだと思うので、学習におすすめです。\n\n# Node.js, Express.js（学習期間 2020年4~5月）\n<img src=\"https://cdn.svgporn.com/logos/express.svg\" />\nExpress.js は、サーバーサイドJavaScriptのNode.jsのWebアプリケーションフレームワークである。シングルページ／マルチページ／混在の各種Webアプリケーションの構築のためにデザインされている。\n<a href=\"http://expressjs.com/\" target=\"_blank\">公式ページ</a>\n\nVue.jsを学習して、フロントエンドとAPIサーバを分けてシステム設計をするのが、昨今の主流と言うことを知り、手軽にAPIサーバを作成できるフレームワークであるExpressを学習しました。\nこれまでRuby on RailsやDjangoのようなモノシリックなフレームワークばかり触っていたので、Expressを学習して、バックエンドの世界観がかなり変わりました。Rails, Django, Laravelしか触ったことない方は、ぜひ触ってみて欲しいと思います。\n\n# Amazon Web Service（ECS, RDS, S3, Lambda）（学習期間 2020年5月）\n<img src=\"https://cdn.svgporn.com/logos/aws.svg\" />\nExpressとVue.jsで作成したWebアプリをデプロイするために、AWSの中の上記のサービスについて学習しました。\n以下が実際に構築したシステム図です。\n<img src=\"https://pbs.twimg.com/media/EYYyCNiU4AMMEho?format=jpg&name=large\" />\n\n# Docker（学習期間 2020年4~5月）\n<img src=\"https://cdn.svgporn.com/logos/docker.svg\" />\nDockerは、コンテナ仮想化を用いてアプリケーションを開発・配置・実行するためのオープンソースソフトウェアあるいはオープンプラットフォームである。 Dockerはコンテナ仮想化を用いたOSレベルの仮想化によりアプリケーションを開発・実行環境から隔離し、アプリケーションの素早い提供を可能にする。\n<a href=\"https://www.docker.com/\" target=\"_blank\">公式ページ</a>\n\nExpressでAPIサーバを作成する際に、一緒にDockerを学習しました。\nDockerはめちゃめちゃ便利で、これを学習して以降Webアプリを開発する時は、必ずDockerを使って、環境構築を行っています。\nデプロイもコンテナベースで行うことが多く、ECSなどもコンテナでのデプロイをすることができます。\n\n# Circle CI（学習期間 2020年4~5月）\n<img src=\"https://cdn.svgporn.com/logos/circleci.svg\" />\nCircleCI を利用すると、ビルド、テスト、デプロイ、デリバリーといったプロセスを自動化できるため、信頼性の高いコードをリリースできます。Samsung、Ford Motor Company、Spotify、Lyft、Coinbase、PagerDuty、Stitch Fix、BuzzFeed をはじめ数千社の大手企業が、ソフトウェア開発の効率化と品質向上のために CircleCI を採用しています。\n<a href=\"https://circleci.com/ja/\" target=\"_blank\">公式ページ</a>\n\nCircle CIは自動デプロイを行うツールです。ただ、コンテナベースのデプロイしか支援してない？ので、Dockerなどのコンテナ仮想化ツールを扱えることが必須になります。\nCircle CIは便利ではありましたが、最近はGithub Actionsを多用しているため出番はあまりないツールになってしまいました。\nただ、自動デプロイができると開発効率が格段に上がると思うので、ぜひおすすめです。\n\n# Nuxt.js（学習期間 2020年6月）\n<img src=\"https://cdn.svgporn.com/logos/nuxt.svg\" />\nNuxt.jsは、Vue.js、Node.js、Webpack、Babel.jsに基づく無料のオープンソースWebアプリケーションフレームワークです。このフレームワークは、「ユニバーサルアプリケーションのメタフレームワーク」として宣伝されています。\n<a href=\"https://ja.nuxtjs.org/\" target=\"_blank\">公式ページ</a>\n\nNuxt.jsは、Vue RouterやVuexなどがデフォルトで入っているので、めちゃくちゃ便利です。\nただ、SSRの挙動をしっかり理解して制御するのは、難しいのでVue.jsを書く時とは、違う注意点があります。\n\nNuxt.jsはフロントエンドフレームワークの私のメインウェポンなので、とてもお気に入りです。\n\n# Rust（学習期間 2020年7月）\n<img src=\"https://cdn.svgporn.com/logos/rust.svg\" />\nRustはMozillaが支援するオープンソースのシステムプログラミング言語である。 Rust言語は速度、並行性、安全性を言語仕様として保証するC言語、C++に代わるシステムプログラミングに適したプログラミング言語を目指している。\n<a href=\"https://www.rust-lang.org/ja\" target=\"_blank\">公式ページ</a>\n\nRustはC++の悪いところをカバーしたような言語で、C++を知っている人には、ぜひ触って欲しい言語です。C++の悪いところが、どんどん分かってくると思います。\nまた、所有権やライフサイクルなどと言った他の言語にはない概念が存在するので、純粋にコーディング能力も向上すると思います。\n\n# TypeScript（学習期間 2020年6~7月）\n<img src=\"https://cdn.svgporn.com/logos/typescript.svg\" />\nTypeScript はマイクロソフトによって開発され、メンテナンスされているフリーでオープンソースのプログラミング言語である。TypeScriptはJavaScriptに対して、省略も可能な静的型付けとクラスベースオブジェクト指向を加えた厳密なスーパーセットとなっている。\n<a href=\"https://www.typescriptlang.org/\" target=\"_blank\">公式ページ</a>\n\n最近のフロントエンド開発には、TypeScriptが主流になっていると聞いて、学習しました。これを使えるようになると、生のJSは書けなくなるくらい型依存症になります。\nただ、Vue.jsとの相性がそこまで良くないので、Vue✖️TypeScriptで使用するときは、若干ストレスに感じる時があります。\n\n# Nest.js（学習期間 2020年6~7月）\n<img src=\"https://cdn.svgporn.com/logos/nestjs.svg\" />\nNest（NestJS）は、効率的でスケーラブルなNode.jsサーバー側アプリケーションを構築するためのフレームワークです。プログレッシブJavaScriptを使用し、TypeScriptで構築され、完全にサポートされ（開発者は、純粋なJavaScriptでコーディングできます）、OOP（オブジェクト指向プログラミング）、FP（関数型プログラミング）、およびFRP（関数型リアクティブプログラミング）の要素を組み合わせます。\n<a href=\"https://nestjs.com/\" target=\"_blank\">公式ページ</a>\n\nNest.jsは私が最も好きなフレームワークです。このフレームワークはDI（依存性の注入）に基づいた構成になっていて、めちゃくちゃ良いなと思ってます。\nまた、cliでディレクトリやファイルを作成することができる点やTypeScriptでしか書けないため、チーム開発に向いているフレームワークだと思ってます。\n\n# Graph QL（学習期間 2020年8月）\n<img src=\"https://cdn.svgporn.com/logos/graphql.svg\" />\nGraphQLはAPI向けに作られたクエリ言語およびランタイムである。 ウェブAPIの開発に、RESTやその他のWebサービスと比較して、効率的、堅牢、フレキシブルなアプローチを提供する。GraphQLでは、クライアントが必要なデータの構造を定義することができ、サーバーからは定義したのと同じ構造のデータが返される\n<a href=\"https://graphql.org/\" target=\"_blank\">公式ページ</a>\n\n# React（学習期間 2020年8月）\n<img src=\"https://cdn.svgporn.com/logos/react.svg\" />\nReact は、Facebookとコミュニティによって開発されているユーザインタフェース構築のためのJavaScriptライブラリである。React.jsまたはReactJSの名称でも知られている。 Reactはシングルページアプリケーションやモバイルアプリケーションの開発におけるベースとして使用することができる。\n<a href=\"https://ja.reactjs.org/\" target=\"_blank\">公式ページ</a>\n\nフロントエンド開発をVue✖️TypeScriptでやっていて、Reactの方がTypeScriptと相性が良いというのを聞いて、学習しました。\n確かに、HTMLの部分で型が効くReactの方がTypeScriptと相性が良いし、storeとの相性も良くて、Vueから乗り換えるのもありかなと思いました。でも、Vue.jsは、v-ifやv-forなどがあったり、元々やっていたということもあって、しばらくはVue.jsで良いかなと思います。\n自分の印象では、Reactはロジックが書きやすく、VueはHTML部分が書きやすいという印象です。\n\n# Go（学習期間 2020年9月）\n<img src=\"https://cdn.svgporn.com/logos/gopher.svg\" />\nGoはプログラミング言語の1つである。2009年、GoogleでRobert Griesemer、ロブ・パイク、ケン・トンプソンによって設計された。Goは、静的型付け、C言語の伝統に則ったコンパイル言語、メモリ安全性、ガベージコレクション、構造的型付け、CSPスタイルの並行性などの特徴を持つ。\n<a href=\"https://golang.org/\" target=\"_blank\">公式ページ</a>\n\nGoは、流行っているからやってみようという乗りでやってみました。パッケージ管理の仕組みが素晴らしいという印象で、コードの書き味は、そこそこっていう感じです（個人の意見）。\nGoでバックエンド開発をする時は、フレームワークにGin, ORMにGORMを使用しています。もし、他に良いのがあれば教えてください。\n\n# Next.js(学習期間 2020年11月)\n<img src=\"https://cdn.svgporn.com/logos/nextjs.svg\" />\nNext.jsは、オープンソースのReactフロントエンド開発Webフレームワークであり、サーバーサイドレンダリングやReactベースのWebアプリケーション用の静的Webサイトの生成などの機能を有効にします。 \n<a href=\"https://nextjs.org/\" target=\"_blank\">公式ページ</a>\n\n今年、最後に学習したものは、Next.jsです。最近、Nuxt.js vs Next.jsみたいなものをよく見るので、自分自身の手で確かめたく学習しました。\n自分的には、Nuxt.jsよりNext.jsの方がいろいろと進んでいるなという印象でした。特に、SSG（静的サイトジェネレーター）の機能がNext.jsの方が圧倒的に良いと感じたので、今後FirebaseやNetlifyにフロントエンドをデプロイするときは、使用したいなと思います。\n\n# まとめ\n以上で、今年自分が学習した技術の紹介は終わりです。ここに書いたもの以外にも、Riot.js, Svelte, PHP（Laravel）, Scala（Play Framework）, Swift, Google Cloud Platform, Netlify, Github Actionsなど本当にいろいろなものを触りました。\n\n今年は、1人で技術を探究することに専念しましたが、来年は、いろいろな人と関わりを持って、もっと成長できる1年にしていきたいと思います！\n"
  },
  {
    "title": "Serverless FrameworkでLINE Botを作ってみた！",
    "content": "# Serverless Frameworkとは\n![https___camo.githubusercontent.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/d1dec5fc-f941-c194-85f1-3d2c04dd7060.jpeg)\n\n\n<a href=\"https://www.serverless.com/\" target=\"_blank\">Serverless Framework</a> はFaaS(Function as a Service)やクラウドのDB,Storageでアプリケーションを構成するためのフレームワークです。AWS以外にもGCP, Azureにも対応しています。\n導入方法などは、<a href=\"https://qiita.com/horike37/items/b295a91908fcfd4033a2\" target=\"_blank\">こちらの記事</a>を参考にしてください。\n\n# 注意事項\n・コマンドはMacを想定しているのでWindowsの方は、設定方法が異なると思います。\n・AWSのアカウントを持っていないと、できません。\n・LambdaやAPI Gatewayの設定を簡単に出来過ぎてしまうため、初めて触る方には、あまり理解できないかと思います。\n\n# LINE Botを作成\n<a href=\"https://developers.line.biz/ja/\" target=\"_blank\">LINE Dvelopers</a>でLINE Botを作成します。\nログインしたら、画面下の作成をクリックします。\n![スクリーンショット 2020-11-04 12.49.01.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/f461f459-a11e-ff1b-92ea-84e1005f82c3.png)\n\nそうすると、プロバイダー名を入力する画面が表示されるので、好きな名前を入力します。\n![スクリーンショット 2020-11-04 12.53.55.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/86c20ebf-6e0f-a011-97b1-eef8bc9de472.png)\n\nこれでプロバイダーを作成できました。\n次にチャネル(LINE Bot)を作成します。今回はおうむ返しするLINE Botを作成するのでMessaging APIを選択します。\n![スクリーンショット 2020-11-04 12.55.23.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/30fd4b49-65a0-2d7d-485e-8720121ecd47.png)\n\nLINE Botのアイコンや名前を入力する画面が出てくるので、入力します。\n![スクリーンショット 2020-11-04 12.59.58.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/df3d3189-7566-7eb5-39aa-d6a51c938af6.png)\n\nこれでLINE Botの作成は終了です。\n\n# システム構成\n今回作成するシステムは、ユーザーがLINE Botにメッセージを送信すると、WebhookでLambdaの関数が実行されるという感じです。\n赤く囲っているところをServerless Frameworkで実装します。\n![スクリーンショット 2020-11-04 13.08.13.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/313c3908-04b1-1c2c-39d8-e79db46840ab.png)\n\n# AWSのアカウントをPCに関連付ける\nAWS-CLIを利用してPCにAWSの情報を設定しておきます。\n<a href=\"https://qiita.com/reflet/items/e4225435fe692663b705\" target=\"_blank\">この記事</a>を参考に\n\n# Let's Serverless\nServerless FrameworkをPCに導入したら、ターミナルで作業ディレクトリに移動して、以下のコマンドを実行します。\n--templateオプションで指定しているのは、Lambdaで使用するプログラミング言語で、--pathオプションで指定しているのは、プロジェクト名とプロジェクトの配置場所です。適宜変更してください。\n\n```\n$ serverless create --template aws-python3 --path line-bot\n```\n\nコマンドを実行すると以下のディレクトリ構成でプロジェクトが作成されると思います。\n\n```\nline-bot\n    ├ .gitignore\n    ├ handler.py\n    └ serverless.yml\n```\n\n# serverless.ymlを書き換える\nserverless.ymlを以下に書き換えます。\n\n```serverless.yml\nservice: line-bot\nframeworkVersion: '2'\n\nprovider:\n  name: aws\n  runtime: python3.8\n  region: ap-northeast-1  # 東京リージョンを指定\n\n# Lambda関数の設定\nfunctions:\n  callback:\n    handler: handler.callback\n\n    # API Gatewayの設定\n    events:\n      - http:\n          path: callback\n          method: post\n```\n\nこれで、API GatewayとLambdaの設定が終わりです。\n簡単すぎますね...\n\n# Lambda関数を実装\n次にLambdaが実行する関数を実装します。\n## Pythonの仮想環境を作成\nPythonなので、まず仮想環境を作ります。\n自分は、venvで仮想環境を作りますが、conda や virtualenvで作る方もいると思うので、そこは適宜変更してください。\n\n```\n$ python3 -m venv line-bot\n```\n\nこれを実行すると、line-botというディレクトリが生成されると思います。\n\n```\nline-bot\n    ├ line-bot/  <-- 仮想環境用ディレクトリ\n    ├ .gitignore\n    ├ handler.py\n    └ serverless.yml\n```\n\n生成されたら、以下のコマンドでactivateしてください。\n\n```\n$ source line-bot/bin/activate\n```\n\n## LINE Botに使用するライブラリ\nLINE Botの操作には、line-bot-sdkというライブラリを使用します。\n\n```\n$ pip3 install line-bot-sdk\n```\n\n## handler.pyに実装\nこれで準備は完了なので、実際にコードを書きます。\n\n```handler.py\nfrom linebot.models import (\n    MessageEvent, TextMessage, TextSendMessage, ImageMessage\n)\nfrom linebot.exceptions import (\n    InvalidSignatureError\n)\nfrom linebot import (\n    LineBotApi, WebhookHandler\n)\nimport os\n\naccess_token = os.environ['LINE_CHANNEL_ACCESS_TOKEN']  // Lambdaの環境変数から取得\nsecret_key = os.environ['LINE_CHANNEL_SECRET']          // Lambdaの環境変数から取得\n\nline_bot_api = LineBotApi(access_token)\nhandler = WebhookHandler(secret_key)\n\n// LINE BotのWebhookで実行される関数\ndef callback(event, context):\n    try:\n        signature = event[\"headers\"][\"x-line-signature\"]\n        event_body = event[\"body\"]\n        handler.handle(event_body, signature)\n    except InvalidSignatureError as e:\n        logger.error(e)\n        return {\"statusCode\": 403, \"body\": \"Invalid signature. Please check your channel access token/channel secret.\"}\n    except Exception as e:\n        logger.error(e)\n        return {\"statusCode\": 500, \"body\": \"exception error\"}\n    return {\"statusCode\": 200, \"body\": \"request OK\"}\n\n// おうむ返しをする関数\n@handler.add(MessageEvent, message=TextMessage)\ndef handle_message(event):\n    line_bot_api.reply_message(\n        event.reply_token,\n        TextSendMessage(text=event.message.text)\n    )\n```\n\nこれで、Lambda関数の実装は終了です。\n\n# requirements.txtを出力\nLambdaのPythonで使用するライブラリのリストを出力します。\nactivateした状態で以下のコマンドを実行します。\n\n```\n$ pip3 freeze > requirements.txt\n```\n\nrequirements.txtに記載されているライブラリをデプロイしたときに、LambdaにインストールしてもらうためにServerless Frameworkにpluginを追加します。\n\n```\n$ npm install --save serverless-python-requirements\n```\n\nこれでローカルで使用しているライブラリがLambdaでも利用できるようになります。\n\n# ひとまずデプロイ\nここまで来たら、一回デプロイをして見ましょう\n以下のコマンドでデプロイできます。\nslsは、serverlessの短縮形です。\n\n```\n$ sls deploy\n```\n\nこれを実行したら、AWSのコンソール画面にいき、東京リージョンのLambdaを見にいきましょう\nすると、実際にデプロイされていることが分かると思います。\n\n# LINE Botのアクセストークンとシークレットキーを見にいく\n実装したLambda関数を実行するためには、LINE Botのアクセストークンとシークレットキーが必要になるので、LINE Developersのコンソール画面で見ます。\n\nアクセストークンは、Messaging API設定の下の方にあります。\n![スクリーンショット 2020-11-04 14.40.37.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/69348b9f-be68-dcb8-f5f6-10ff01e5e6d4.png)\n\nシークレットキーは、チャネル基本設定の下の方にあります。\n![スクリーンショット 2020-11-04 14.38.04.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/afef6ead-488f-acfb-6c6b-8e00322e1af8.png)\n\n\n# Lambdaに環境変数を設定\n上記で見た値をLambdaの環境変数にセットします。\nこの画面の少し下に、環境変数を設定できるところがあるので、このような形で保存します。\n\n|キー  |値 \n|---|---|---|\n|LINE_CHANNEL_ACCESS_TOKEN |✖️✖️✖️✖️✖️✖️\n|LINE_CHANNEL_SECRET  |✖️✖️✖️✖️✖️✖️  |\n\n![スクリーンショット 2020-11-04 14.30.44.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/a7913144-fc8a-4e0a-512d-ef15a273912d.png)\n\n\n# API GatewayのURLを見る\n以下のところをクリックすると、API Gatewayから発行されているURLを確認できるので、見ておきましょう。 \n![スクリーンショット 2020-11-04 14.30.44.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/1489d893-a4a8-da13-bca8-12df7d3e3f8a.png)\n\n\n# LINE BotのWebhookにLambda関数のURLを設定\nLINE BotのMessaging API設定の画面のWebhookにAPI GatewayのURLを入力します。\n![スクリーンショット 2020-11-04 14.48.12.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/972b42ac-56f8-a1a9-3a4a-407184d99f2b.png)\n入力後、検証ボタンをクリックして、成功画面が表示されたら、終了です。\nLINE BotのQRコードが上の方に表示されていると思うのうで、そこから友達追加をすれば、おうむ返しBotで遊べると思います。\n\n# もしも、詰まったら\n上記の検証をクリックして、レスポンスエラーが表示されたら、Lambda関数でエラーが出ていると思うので、以下のモニタリングのところから\n![スクリーンショット 2020-11-04 14.28.54.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/b6572260-e3d2-f67d-ba19-1204cd56f24e.png)\n\nこの「CloudWatchのログを表示」をクリックすると、Lambda関数のログを見ることができるので、それを見てデバッグをして見てください。\n![スクリーンショット 2020-11-04 15.03.52.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/533652/10ff2a54-d957-3293-68ed-df150f09f39d.png)\n"
  },
  {
    "title": "Vue ✖️ Firebase Storageで画像保存",
    "content": "# はじめに\nVue.jsとFirebaseの導入については、省いております．\nご了承ください．\n\n# 画像投稿機能 Vue.jsのコード\n\n### プレビュー付き画像フィールド\n\n\n``` VImgField.vue\n<template>\n  <div>\n    <v-row v-if=\"uploadedImage\" justify=\"center\" align=\"center\">\n      <v-sheet width=\"300\">\n        <v-img :src=\"uploadedImage\" />\n      </v-sheet>\n    </v-row>\n    <div v-cloak @drop.prevent=\"addDropFile\" @dragover.prevent>\n      <v-row justify=\"center\" align=\"center\">\n        <v-col cols=\"11\" sm=\"8\" md=\"6\">\n          <v-file-input\n            v-model=\"file\"\n            accept=\"image/png, image/jpeg, image/jpg, image/bmp\"\n            prepend-icon=\"mdi-camera\"\n            placeholder=\"画像ファイル(png, jpeg, jpg, bmp)を選択\"\n          />\n        </v-col>\n      </v-row>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  SetupContext,\n  ref,\n  watch,\n} from '@vue/composition-api';\n\n// アップロードを許可する拡張子\nconst allowExts: string[] = ['jpg', 'jpeg', 'png', 'bmp'];\n\n// ファイル名から拡張子を取得する関数\nconst getExt = (filename: string): string => {\n  const pos = filename.lastIndexOf('.');\n  if (pos === -1) {\n    return '';\n  }\n  return filename.slice(pos + 1);\n};\n\n// ファイルが許可されている拡張子か確認する関数\nconst checkExt = (file: File | undefined): boolean => {\n  if (file) {\n    const ext = getExt(file.name).toLowerCase();\n    if (allowExts.indexOf(ext) === -1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// 画像ファイルをBase64に変換\nconst getBase64 = (file: File): Promise<string | ArrayBuffer | null> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = (error) => reject(error);\n  });\n};\n\n// Composition API\nexport default defineComponent({\n  setup(props, context: SetupContext) {\n    const uploadedImage = ref<string | ArrayBuffer | null>(null);\n    const file = ref<File | undefined>(undefined);\n\n    // ファイルがドラッグで追加されたときのメソッド\n    const addDropFile = (e: DragEvent) => {\n      const dt: DataTransfer | null = e.dataTransfer;\n      if (dt) {\n        file.value = dt.files[0];\n      }\n    };\n\n    // ファイルの変更を監視し\n    // 変更があれば、Base64に変換しviewを表示\n    watch(file, (newFile, oldFile) => {\n      if (checkExt(newFile)) {\n        if (newFile) {\n          getBase64(newFile).then((image: string | ArrayBuffer | null) => {\n            uploadedImage.value = image;\n            context.emit('change-file', file.value);\n          });\n        } else {\n          uploadedImage.value = null;\n        }\n      } else {\n        file.value = oldFile;\n        context.emit('error-occurred', 'ファイル形式が正しくありません');\n      }\n    });\n\n    return {\n      uploadedImage,\n      file,\n      addDropFile,\n    };\n  },\n});\n</script>\n\n<style scoped>\nlabel > input {\n  display: none;\n}\n\nlabel {\n  padding: 0 1rem;\n  border: solid 1px #888;\n}\n\nlabel::after {\n  content: '+';\n  font-size: 1rem;\n  color: #888;\n  padding-left: 1rem;\n}\n</style>\n\n```\n\n### 画像送信フォーム\n\n```VPostForm.vue\n<template>\n  <v-row>\n    <v-col cols=\"11\" sm=\"8\">\n      <v-alert v-show=\"error\" type=\"error\">{{ error }}</v-alert>\n    </v-col>\n    <v-col cols=\"11\">\n      <a :href=\"url\" target=\"_blank\">{{ url }}</a>\n    </v-col>\n    <v-col cols=\"11\">\n      <v-img-field\n        @change-file=\"changeFile\"\n        @error-occurred=\"catchError\"\n      />\n    </v-col>\n    <v-col cols=\"10\">\n      <v-btn @click=\"putImage\">\n        Post\n        <v-icon>\n          mdi-telegram\n        </v-icon>\n      </v-btn>\n    </v-col>\n  </v-row>\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue';\nimport VImgField from '@/components/VImgField.vue';\n// Firebaseにアップロードするモジュール\nimport Uploader from '@/utils/uploader';\n\nexport default Vue.extend({\n  name: 'VPostForm',\n  components: {\n    VImgField\n  },\n  data: () => ({\n    file: {} as File,\n    error: '',\n    url: ''\n  }),\n  methods: {\n    changeFile(uploadedFile: File) {\n      this.file = uploadedFile\n    },\n    catchError(msg: string) {\n      this.error = msg\n    },\n    // アップロード\n    async putImage() {\n      this.isLoading = true;\n      try {\n        this.url = await Uploader.put(this.file);\n      } catch (err) {\n        this.error = err;\n      }\n      this.isLoading = false;\n    },\n  }\n})\n</script>\n```\n\nこれでVueでView機能付きのフォームを作ることができました．\n\n## 少し脱線\n今回のフォームは、Composition APIとOptions APIの両方を使用して、作っています．\n理由として、私は、メソッドが多く複雑なコンポーネントは、Composition APIを使用して、単純なコンポーネントはOptions APIを使用するみたいな使い分けをしています．\n\n# Firebase側の実装\n\n## Firebaseのsetting\n\n```@/plugins/firebase.ts\nimport firebase from 'firebase/app';\nimport 'firebase/auth';\nimport 'firebase/storage';\n\nconst config = {\n  apiKey: process.env.VUE_APP_FIREBASE_API_KEY,\n  authDomain: process.env.VUE_APP_FIREBASE_AUTH_DOMAIN,\n  databaseURL: process.env.VUE_APP_FIREBASE_DATABASE_URL,\n  projectId: process.env.VUE_APP_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.VUE_APP_FIREBASE_STORAGE_PROJECT,\n  messagingSenderId: process.env.VUE_APP_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.VUE_APP_FIREBASE_APP_ID,\n  measurementId: process.env.VUE_APP_FIREBASE_MEASUREMENT_ID,\n};\n\nfirebase.initializeApp(config);\n\nexport default firebase;\n```\n\n## アップロードをする関数\n\n```@/utils/uploader.ts\nimport firebase from '@/plugins/firebase'\nconst storageRef = firebase.storage().ref();\n\nexport default {\n  put(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      // ファイルのパスを生成\n      const mountainsRef = storageRef.child(`insects/${file.name}`);\n\n      // ファイルをアップロード\n      mountainsRef\n        .put(file)\n        .then((snapshot) => {\n          // アップロードしたファイルのURLを取得\n          snapshot.ref\n            .getDownloadURL()\n            .then((downloadURL: string) => {\n              resolve(downloadURL);\n            })\n            .catch((error) => {\n              reject(error.message);\n            });\n        })\n        .catch((error) => {\n          reject(error.message);\n        });\n    });\n  },\n}\n```\n\nこれで実装できます\n"
  },
  {
    "title": "Vue.js導入方法",
    "content": "# 導入前に\n\n```\n$ node -v\n$ npm -v\n```\n\n上記をターミナルで打ち込んで何も出ない人は見てください\n\n# 導入 ( node, npm )\nMacの方は<a href=\"https://qiita.com/kyosuke5_20/items/c5f68fc9d89b84c0df09\" target=\"_blank\" rel=\"noopener\">こちらのサイト</a>を参考してください\n\nWindowsの方は<a href=\"https://qiita.com/maecho/items/ae71da38c88418b806ff\" target=\"_blank\" rel=\"noopener\">こちらのサイト</a>を参考してください\n\n# 導入 ( Vue-cli, vue )\n```\n$ npm install -g vue-cli\n```\n以上のコマンドを打ち込んでください\n\n```\n$ vue -V\n```\nと打ち込んでversionが表示されれば完了です\n"
  }
]
